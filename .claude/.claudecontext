# Claude Context for DIIID_IMAS Project

## Data Privacy and Testing Policy

**IMPORTANT**: This project works with restricted DIII-D fusion data that is NOT publicly accessible.

### Testing Restrictions for AI Assistants:
- **NEVER run pytest or any test commands** that would fetch real MDS+ data
- **NEVER execute Python code** that calls `mdsvalue()` or connects to DIII-D databases
- **NEVER run any integration tests** without explicit user permission for each execution
- The user will run all tests locally - they have appropriate data access credentials

### Why:
- Running tests would expose restricted fusion research data to the AI assistant
- Data access is controlled and requires proper authorization
- All data remains on user's local machine with proper access controls

### What you CAN do:
- Write test code and test fixtures
- Review and suggest improvements to test structure
- Help debug test failures by reading error messages/logs provided by user
- Modify source code and test files
- Use static analysis tools that don't execute code

### What you CANNOT do:
- Execute any command that fetches MDS+ data
- Run pytest on tests that use real data
- Run Python scripts that import `omas.mdsvalue` and execute queries
- Background process any data-fetching operations

**If the user asks you to run tests**: Politely remind them of this policy and ask for explicit confirmation that the specific test run does not access restricted data.

## OMAS Usage Patterns

### Fetching all data for a single IDS
To fetch everything OMAS knows how to map for a single IDS, use the glob pattern syntax:

```python
from omas import ODS
from omas.omas_machine import machine_to_omas

ods = ODS()
machine_to_omas(ods, 'd3d', shot_number, 'ece.*')  # For ECE IDS
machine_to_omas(ods, 'd3d', shot_number, 'thomson_scattering.*')  # For Thomson IDS
```

This pattern works for any IDS - just use `'<ids_name>.*'` to fetch all mapped data for that IDS.

### Uncertainty Handling in OMAS
While d3d.py stores `<field>.data` as `unumpy.uarray(nominal, error)` internally, when the data is accessed from the ODS it becomes a normal numpy array with the error accessible separately:

- `ods['ids']['channel'][i]['field']['data']` - returns nominal values as numpy array
- `ods['ids']['channel'][i]['field']['data_error_upper']` - returns uncertainties as numpy array

**Important**: When looking at d3d.py implementation, ignore the `unumpy.uarray()` calls. Just implement:
- `<field>.data` - nominal values
- `<field>.data_error_upper` - uncertainties

OMAS automatically handles the conversion from unumpy to separate arrays.

## Python Environment

The user manages the Python environment and dependencies. Assume all standard scientific Python packages are available:
- numpy
- awkward (awkward array library for ragged/nested data)
- pytest and pytest plugins
- All packages listed in requirements files

Do not check for or worry about installing dependencies - focus on implementation.

## Development Philosophy

**This is a new application - no backwards compatibility needed:**
- DO NOT add fallback defaults or compatibility layers
- Tests define expected behavior - let them fail when changes are made
- Explicit is better than implicit - avoid magic fallbacks that hide bugs
- When making changes, we WANT to see test failures to verify behavior changes
- Clear errors are better than silent fallbacks

## OMAS Reference Files for Debugging

Each IDS mapper has a corresponding `*_omas_reference.py` file containing the OMAS implementation:
- `imas_composer/ids/ece_omas_reference.py` - OMAS electron_cyclotron_emission_data implementation
- `imas_composer/ids/thomson_scattering_omas_reference.py` - OMAS thomson_scattering_data implementation

**IMPORTANT: When debugging or stuck on a mapper implementation:**
1. **Read the corresponding OMAS reference file first**
2. Compare the OMAS approach (single query dict, all data upfront) with your implementation
3. Check if you're matching the OMAS pattern for static vs dynamic data fetching
4. Verify your MDS+ paths match the OMAS paths exactly

**Common patterns from OMAS:**
- Static data (known paths): OMAS puts in single `query` dict → use DIRECT stage in imas_composer
- Dynamic data (depends on earlier fetch): OMAS fetches in sequence → use DERIVED stage in imas_composer
- Unit conversions: Match OMAS exactly (e.g., TIME / 1e3, FREQ * 1e9, PHI * pi/180)

**When you get lost in your own code:**
- Stop tracing dependencies in your head
- Open the OMAS reference file
- Compare line-by-line: "What does OMAS fetch?" vs "What am I fetching?"
- Ask: "Is this a static query dict (DIRECT) or does it depend on earlier data (DERIVED)?"

## IDS Configuration YAML Files

Each IDS has a single YAML configuration file containing static values and a field list:
- `imas_composer/ids/ece.yaml`
- `imas_composer/ids/thomson_scattering.yaml`

**YAML Structure (minimal):**
```yaml
static_values:
  ids_properties.homogeneous_time: 0
  line_of_sight.first_point.r: 2.5

fields:
  - ids_properties.homogeneous_time
  - channel.name
  - channel.t_e.data
```

**When implementing a mapper:**
1. Inherit from `IDSMapper` base class in `imas_composer/ids/base.py`
2. Set `CONFIG_PATH` and `DOCS_PATH` class variables
3. Call `super().__init__()` to load config (sets `self.static_values` and `self.supported_fields`)
4. Check OMAS reference for hardcoded values → add to `static_values:` in YAML
5. Add ALL implemented fields to `fields:` list in YAML
6. Use in specs: `self.static_values['key']` (NO fallback defaults!)

**Base class provides:**
- `_load_config()`: Loads YAML configuration
- `self.static_values`: Dict of hardcoded values
- `self.supported_fields`: List of implemented IDS paths
- `get_supported_fields()`: Returns the field list

**Keep it minimal:** IMAS schema already defines types and descriptions - don't duplicate. The field list is for test parametrization and documentation of what's implemented.
