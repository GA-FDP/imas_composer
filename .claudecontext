# Claude Context for DIIID_IMAS Project

## Data Privacy and Testing Policy

**IMPORTANT**: This project works with restricted DIII-D fusion data that is NOT publicly accessible.

### Testing Restrictions for AI Assistants:
- **NEVER run pytest or any test commands** that would fetch real MDS+ data
- **NEVER execute Python code** that calls `mdsvalue()` or connects to DIII-D databases
- **NEVER run any integration tests** without explicit user permission for each execution
- The user will run all tests locally - they have appropriate data access credentials

### Why:
- Running tests would expose restricted fusion research data to the AI assistant
- Data access is controlled and requires proper authorization
- All data remains on user's local machine with proper access controls

### What you CAN do:
- Write test code and test fixtures
- Review and suggest improvements to test structure
- Help debug test failures by reading error messages/logs provided by user
- Modify source code and test files
- Use static analysis tools that don't execute code

### What you CANNOT do:
- Execute any command that fetches MDS+ data
- Run pytest on tests that use real data
- Run Python scripts that import `omas.mdsvalue` and execute queries
- Background process any data-fetching operations

**If the user asks you to run tests**: Politely remind them of this policy and ask for explicit confirmation that the specific test run does not access restricted data.

## OMAS Usage Patterns

### Fetching all data for a single IDS
To fetch everything OMAS knows how to map for a single IDS, use the glob pattern syntax:

```python
from omas import ODS
from omas.omas_machine import machine_to_omas

ods = ODS()
machine_to_omas(ods, 'd3d', shot_number, 'ece.*')  # For ECE IDS
machine_to_omas(ods, 'd3d', shot_number, 'thomson_scattering.*')  # For Thomson IDS
```

This pattern works for any IDS - just use `'<ids_name>.*'` to fetch all mapped data for that IDS.

### Uncertainty Handling in OMAS
While d3d.py stores `<field>.data` as `unumpy.uarray(nominal, error)` internally, when the data is accessed from the ODS it becomes a normal numpy array with the error accessible separately:

- `ods['ids']['channel'][i]['field']['data']` - returns nominal values as numpy array
- `ods['ids']['channel'][i]['field']['data_error_upper']` - returns uncertainties as numpy array

**Important**: When looking at d3d.py implementation, ignore the `unumpy.uarray()` calls. Just implement:
- `<field>.data` - nominal values
- `<field>.data_error_upper` - uncertainties

OMAS automatically handles the conversion from unumpy to separate arrays.

## Python Environment

The user manages the Python environment and dependencies. Assume all standard scientific Python packages are available:
- numpy
- awkward (awkward array library for ragged/nested data)
- pytest and pytest plugins
- All packages listed in requirements files

Do not check for or worry about installing dependencies - focus on implementation.

## OMAS Reference Files for Debugging

Each IDS mapper has a corresponding `*_omas_reference.py` file containing the OMAS implementation:
- `imas_composer/ids/ece_omas_reference.py` - OMAS electron_cyclotron_emission_data implementation
- `imas_composer/ids/thomson_scattering_omas_reference.py` - OMAS thomson_scattering_data implementation

**IMPORTANT: When debugging or stuck on a mapper implementation:**
1. **Read the corresponding OMAS reference file first**
2. Compare the OMAS approach (single query dict, all data upfront) with your implementation
3. Check if you're matching the OMAS pattern for static vs dynamic data fetching
4. Verify your MDS+ paths match the OMAS paths exactly

**Common patterns from OMAS:**
- Static data (known paths): OMAS puts in single `query` dict → use DIRECT stage in imas_composer
- Dynamic data (depends on earlier fetch): OMAS fetches in sequence → use DERIVED stage in imas_composer
- Unit conversions: Match OMAS exactly (e.g., TIME / 1e3, FREQ * 1e9, PHI * pi/180)

**When you get lost in your own code:**
- Stop tracing dependencies in your head
- Open the OMAS reference file
- Compare line-by-line: "What does OMAS fetch?" vs "What am I fetching?"
- Ask: "Is this a static query dict (DIRECT) or does it depend on earlier data (DERIVED)?"

## Static Values Pattern

Hardcoded values (not from MDSplus) are stored in `*_static_values.yaml` files:
- `imas_composer/ids/ece_static_values.yaml` - ECE static values (geometry, properties)
- `imas_composer/ids/thomson_scattering_static_values.yaml` - Thomson static values (currently empty)

**When implementing a mapper:**
1. Check OMAS reference for hardcoded values (look for direct assignments, not MDSplus queries)
2. Add them to the `*_static_values.yaml` file using IMAS schema keys
3. Load in mapper `__init__`: `self.static_values = self._load_static_values()`
4. Use in specs: `synthesize=lambda shot, raw: self.static_values.get('key', default_value)`

**Example static values:**
- ECE: `ids_properties.homogeneous_time: 0`, `line_of_sight.first_point.r: 2.5`
- Thomson: (none currently - all data from MDSplus)

Static values are scalar in YAML. Broadcasting to arrays happens during synthesis based on derived dimensions (e.g., number of channels).
